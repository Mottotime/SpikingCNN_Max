/**
 * Document: Manager Compiler Tutorial (maxcompiler-manager-tutorial.pdf)
 * Chapter: 2      Example: 3      Name: Command Stream
 * MaxFile name: CmdStream
 * Summary:
 *     Computes the sum of the two input streams and sends it to an output
 *     stream. Also generates the three custom memory command streams needed to
 *     control the LMem connected to these streams.
 */
package cmdstream;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

class CmdStreamKernel extends Kernel {

	CmdStreamKernel(KernelParameters parameters, int vectorSize, int maxNeuronNum) {
		super(parameters);

		// we should pass the bit width as parameter instead of maxNeuronNum

		DFEVar count = control.count.simpleCounter(32);
		debug.simPrintf("TICK: %d: ", count);

		DFEFix bramType = dfeFixOffset(16, -8, SignMode.TWOSCOMPLEMENT); // use fix to save the cycle and resource.
		DFEFix uintType = dfeUInt(32);
		DFEFix addressType = dfeUInt(16);

		// vectorSize is the branch number
		DFEVar neuronNum = io.scalarInput("neuronNum", uintType);
		DFEVar mapWidth2 = io.scalarInput("mapWidth2", uintType); // mapWidth^2

		Memory<DFEVar> V = mem.alloc(bramType, maxNeuronNum);
		Memory<DFEVar> gather1 = mem.alloc(bramType, maxNeuronNum);
		Memory<DFEVar> gather2 = mem.alloc(bramType, maxNeuronNum);

		Memory<DFEVar> rowInTable = mem.alloc(dfeUInt(32), maxNeuronNum);
		rowInTable.mapToCPU("rowInTable");

		Count.Params paramsForNeuron = control.count.makeParams(32)
										.withMax(neuronNum);
		Counter neuron_counter = control.count.makeCounter(paramsForNeuron);

		DFEVar neuron_idx = neuron_counter.getCount();
		DFEVar is_input_layer = neuron_idx < mapWidth2;

		DFEVar spikeInput = io.input("spikeInput", dfeFloat(16, 48), is_input_layer);
		DFEVar v_n = is_input_layer ? spikeInput : V.read(neuron_idx.cast(addressType));

/*
		DFEVar enable_input = rom.read(count.cast(dfeUInt(7)));
		DFEVar inB = inB_double.cast(dfeUInt(32));
		//DFEVar inB = mappedRom.read(count.cast(dfeUInt(7)));

		//DFEVar inA = io.input("inA", dfeUInt(32));

		DFEVectorType<DFEVar> vectorType =
			new DFEVectorType<DFEVar>(dfeInt(32), vectorSize);

		DFEVector<DFEVar> inA = io.input("inA", vectorType, control.count.pulse(2, false));
		DFEVector<DFEVar> inA2 = stream.offset(inA, -2);

//		DFEVar totalBursts = io.scalarInput("totalBursts",dfeUInt(32));
//		DFEVar wordsPerBurst = io.scalarInput("wordsPerBurst",dfeUInt(32));
//		DFEVar row_num = io.scalarInput("row_num", dfeUInt(32));


		//CounterChain chain = control.count.makeCounterChain();
		//DFEVar burstCount = chain.addCounter(100, 1);
		//DFEVar wordCount = chain.addCounter(96, 1);

		inB.simWatch("inB");
		inA2.simWatch("inA2");
		////debug.dfePrintf("vectorSize %d, ", vectorSize); // vectorSize is not visible

		CircularBuffer buffer = new CircularBuffer(this, 8, dfeUInt(32));
		buffer.push(constant.var(true), inB);
		//DFEVar inA_address = buffer.pop(constant.var(true));
		DFEVar inA_address = buffer.pop( count > 1 );

		//DFEVar inB_add = stream.offset(inB, 2);//inB.cast(dfeUInt(28));
		//inB_add.simWatch("inB_add");
		//DFEVar inB_eq_count = inB.eq(count);
		//inB_eq_count.simWatch("inB_eq_count");

		LMemCommandStream.makeKernelOutput("AcmdStream",
				//wordCount === 0,
				constant.var(true),                // control
				//inB > 0,
				//inB_add,
				inB,
				//inB.cast(dfeUInt(28)),             // address
				//burstCount,
				//count+40,
				//count,
				//count > 0 ? inB : count,
				//inA_address,
				constant.var(dfeUInt(8), 1),       // size
				constant.var(dfeUInt(7), 0),       // inc
				constant.var(dfeUInt(1), 0),       // stream
				constant.var(true)); // Shall we ? Use false?
		/*
		LMemCommandStream.makeKernelOutput("BcmdStream",
				wordCount === 0,                 // control
				//wordCount >= 0,
				totalBursts + burstCount,        // address
				constant.var(dfeUInt(8), 1),      // size
				constant.var(dfeUInt(1), 0),      // inc
				constant.var(dfeUInt(1), 0),      // stream
				constant.var(false));
		*/
		/*
		LMemCommandStream.makeKernelOutput("OcmdStream",
				count >= 0,                  // control
				row_num + count,     // address
				constant.var(dfeUInt(8), 1),       // size
				constant.var(dfeUInt(1), 0),       // inc
				constant.var(dfeUInt(1), 0),       // stream
				count === (totalBursts - 1));
		*/
		/*
		DFEVector<DFEVar> outputVector =
			vectorType.newInstance(this);
		for(int i = 0; i < vectorSize; i++){

		}*/
/*
		DFEVar result = inA2[0];
		//DFEVar result = inB.cast(dfeInt(32));
		//io.output("oData", inA[0], dfeUInt(32));
		io.output("oData", result, dfeInt(32));//, control.count.pulse(2, false));
*/
	}
}
